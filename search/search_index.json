{
    "docs": [
        {
            "location": "/", 
            "text": "Home\n\n\nWelcome to the documentation site for WCM, the dependency manager for Web Components.\n\n\n\n\nWarning\n\n\nThis project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!\n\n\n\n\nGetting started\n\n\nIf you haven't done so already, install the command-line tool. This package includes every you'll need to incorporate all the benefits of\nWCM into your project.\n\n\nnpm i wcm -g\n\n\n\n\n\n\n\nHow awkward, we're still working on this!", 
            "title": "Home"
        }, 
        {
            "location": "/#home", 
            "text": "Welcome to the documentation site for WCM, the dependency manager for Web Components.   Warning  This project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!", 
            "title": "Home"
        }, 
        {
            "location": "/#getting-started", 
            "text": "If you haven't done so already, install the command-line tool. This package includes every you'll need to incorporate all the benefits of\nWCM into your project.  npm i wcm -g   How awkward, we're still working on this!", 
            "title": "Getting started"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\n\n\nWarning\n\n\nThis project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!\n\n\n\n\nMotivation\n\n\nUnbundled projects, specifically those that are leveraging Web Components, suffer from some interesting caching obstacles. The toughest\nbeing that you can't aggressively cache imports, as lookup paths aren't updated when dependencies are updated, and this has been a key\ndownside holding back the wide adoption of unbundled code distribution. Another issue haunting some frontend developers, that doesn't only\naffect unbundled projects but mostly pokes its ugly head into Bower managed projects, is poor dependency resolution.\n\n\nThe two issues outlined above are the inspiration behind WCM. Web applications need a reliable tool to organise their dependencies that\nalso complements the environment that they run in.\n\n\nSolution\n\n\nThe issue approaching the above challenges with conventional package managers lies in the way that they store their dependencies. When\ninstalling a package via NPM, Yarn, or Bower, that package is store locally under it's unique package name. Whilst there is nothing wrong\nwith this approach, it doesn't complement web applications.\n\n\nOver the past decades most websites and Progressive Web Applications will have imported some code from a CDN. Packages are organised a\nlittle differently in a CDN, they're subgrouped by a version number, and it's only with this extra level of specificity that a CDN can\naggresively cache packages. WCM copies this organisational strucutre when installing your dependencies, enabling you to work against a\nCDN-like interface with all of the benefits that they bring to the table.\n\n\nHaving your dependencies organised in a way that objectively better suits web applications is all well and good, however, a change in the\nstructure of a project's dependencies would call for a change in the way those dependencies are referenced. Ouch! Fear not though, WCM is\nbackwards compatible with today's methods, it actually prefers them, so you won't need to change a single import statement.\n\n\nThrough the wonders of Service Workers, WCM emulates a reverse proxy within the client's browser that fetches the exact version of each\ndependency as and when it's requested.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "Warning  This project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!", 
            "title": "About"
        }, 
        {
            "location": "/about/#motivation", 
            "text": "Unbundled projects, specifically those that are leveraging Web Components, suffer from some interesting caching obstacles. The toughest\nbeing that you can't aggressively cache imports, as lookup paths aren't updated when dependencies are updated, and this has been a key\ndownside holding back the wide adoption of unbundled code distribution. Another issue haunting some frontend developers, that doesn't only\naffect unbundled projects but mostly pokes its ugly head into Bower managed projects, is poor dependency resolution.  The two issues outlined above are the inspiration behind WCM. Web applications need a reliable tool to organise their dependencies that\nalso complements the environment that they run in.", 
            "title": "Motivation"
        }, 
        {
            "location": "/about/#solution", 
            "text": "The issue approaching the above challenges with conventional package managers lies in the way that they store their dependencies. When\ninstalling a package via NPM, Yarn, or Bower, that package is store locally under it's unique package name. Whilst there is nothing wrong\nwith this approach, it doesn't complement web applications.  Over the past decades most websites and Progressive Web Applications will have imported some code from a CDN. Packages are organised a\nlittle differently in a CDN, they're subgrouped by a version number, and it's only with this extra level of specificity that a CDN can\naggresively cache packages. WCM copies this organisational strucutre when installing your dependencies, enabling you to work against a\nCDN-like interface with all of the benefits that they bring to the table.  Having your dependencies organised in a way that objectively better suits web applications is all well and good, however, a change in the\nstructure of a project's dependencies would call for a change in the way those dependencies are referenced. Ouch! Fear not though, WCM is\nbackwards compatible with today's methods, it actually prefers them, so you won't need to change a single import statement.  Through the wonders of Service Workers, WCM emulates a reverse proxy within the client's browser that fetches the exact version of each\ndependency as and when it's requested.", 
            "title": "Solution"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\n\n\nWarning\n\n\nThis project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!\n\n\n\n\n\n\nHow awkward, we're still working on this!", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "Warning  This project is currenty in beta, and while we're confident that it's awesome it's certainly not production ready!    How awkward, we're still working on this!", 
            "title": "Usage"
        }
    ]
}